# Task Management System

A modern task management microservice built with Spring Boot, PostgreSQL, and Redis, following Domain-Driven Design (DDD) principles. Designed for deployment on Azure Container Apps with Docker containerization.

## 🏗️ Architecture

![Task Management System Architecture](./assets/architecture-diagram.svg)

### Tech Stack
- **Backend**: Spring Boot 3.5.5 with Java 21
- **Database**: PostgreSQL (UUID primary keys)
- **Cache**: Redis
- **Containerization**: Docker & Docker Compose
- **Deployment**: Azure Container Apps
- **Build Tool**: Maven

### Design Principles
- **Domain-Driven Design**: Clean architecture with separated layers
- **Relational Model**: PostgreSQL with UUID primary keys
- **Microservices Ready**: Stateless, containerized, and cloud-native

## 📋 Features

- ✅ Create, update, and manage tasks
- ✅ Board-based task organization
- ✅ Task assignment and status tracking
- ✅ Priority management
- ✅ Overdue task detection
- ✅ Redis caching for performance
- ✅ Health checks and monitoring
- ✅ Docker containerization
- ✅ Cloud deployment ready

## 🚀 Quick Start

### Prerequisites
- Java 21
- Maven 3.6+
- Docker & Docker Compose
- Git

### Local Development Setup

1. **Clone the repository**
   ```bash
   git clone <your-repo-url>
   cd app
   ```

2. **Start infrastructure with Docker**
   ```bash
   docker-compose up -d mongodb redis
   ```

3. **Run the application locally**
   ```bash
   mvn spring-boot:run
   ```

4. **Access the application**
   - API: http://localhost:8081
   - Health Check: http://localhost:8081/actuator/health

### Full Docker Deployment

1. **Build and start everything**
   ```bash
   docker-compose up --build
   ```

2. **Run in background**
   ```bash
   docker-compose up -d --build
   ```

3. **View logs**
   ```bash
   docker-compose logs -f app
   ```

4. **Stop services**
   ```bash
   docker-compose down
   ```

## 📁 Project Structure

```
app/
├── src/
│   ├── main/
│   │   ├── java/com/company/app/
│   │   │   ├── application/
│   │   │   │   ├── dto/           # Data Transfer Objects
│   │   │   │   └── service/       # Application Services
│   │   │   ├── domain/
│   │   │   │   ├── entity/        # Domain Entities
│   │   │   │   ├── repository/    # Repository Interfaces
│   │   │   │   └── valueobject/   # Value Objects
│   │   │   ├── infrastructure/    # External concerns
│   │   │   └── presentation/      # Controllers
│   │   └── resources/
│   │       ├── application.properties    # Local config (PostgreSQL)
│   │       └── application-docker.yml    # Docker config
│   └── test/                      # Test classes
├── docker-compose.yml             # Multi-service setup
├── Dockerfile                     # Application container
└── pom.xml                       # Maven dependencies
```

## 🗄️ Data Model

### Task Entity (PostgreSQL)
- `id`: UUID (generated by Hibernate `@UuidGenerator`)
- `title`: string (required)
- `description`: text
- `status`: enum [`TODO`, `IN_PROGRESS`, `DONE`]
- `priority`: enum [`LOW`, `MEDIUM`, `HIGH`, `URGENT`]
- `board_id`: string (required)
- `assigned_to`: string
- `due_date`: timestamp
- `created_at`, `updated_at`: timestamps (auto-managed)

## 🔧 Configuration

### Profiles

- **default**: Local development with localhost connections
- **docker**: Container environment with service names
- **test**: Embedded databases for testing

## 📊 API Endpoints

### Task Management
- `POST /api/tasks` - Create task (returns UUID id)
- `GET /api/tasks/{id}` - Get task by UUID
- `PUT /api/tasks/{id}` - Update task by UUID
- `DELETE /api/tasks/{id}` - Delete task by UUID
- `PUT /api/tasks/{id}/status` - Update task status

### Queries
- `GET /api/tasks/board/{boardId}` - Get tasks by board
- `GET /api/tasks/assignee/{userId}` - Get tasks by assignee
- `GET /api/tasks/status/{status}` - Get tasks by status
- `GET /api/tasks/overdue` - Get overdue tasks

### Health & Monitoring
- `GET /actuator/health` - Application health
- `GET /actuator/info` - Application info
- `GET /actuator/metrics` - Application metrics

## 🐳 Docker Services

### Application Stack
```yaml
services:
  app:           # Spring Boot application (port 8081)
  redis:         # Redis cache (port 6379)
  mongo-express: # MongoDB web UI (port 8081)
```

### Container Features
- **Multi-stage builds** for optimized image size
- **Non-root user** for security
- **Health checks** for container orchestration
- **Persistent volumes** for data
- **Custom networks** for service isolation

## ☁️ Azure Container Apps Deployment

### Free Tier Benefits
- **180,000 vCPU-seconds** monthly
- **360,000 GiB-seconds** monthly
- **2 million requests** monthly
- **Auto-scaling to zero** (cost optimization)

### Deployment Steps
1. **Create Container App Environment**
2. **Deploy from GitHub** (automatic builds)
3. **Configure environment variables**
4. **Set up custom domains** (optional)

### Container Apps Features
- ✅ Serverless scaling
- ✅ Automatic HTTPS
- ✅ Built-in load balancing
- ✅ Blue-green deployments
- ✅ Integrated monitoring

## 🧪 Testing

### Run Tests
```bash
# Unit tests
mvn test

# Integration tests with embedded MongoDB
mvn verify

# Test with specific profile
mvn test -Dspring.profiles.active=test
```

### Test Configuration
- **Embedded MongoDB** for integration tests
- **TestContainers** for full stack testing
- **Separate test profiles** for isolation

## 🚀 Development Workflow

### Local Development
1. Start infrastructure: `docker-compose up -d mongodb redis`
2. Run app: `mvn spring-boot:run`
3. Make changes and test
4. Commit and push to trigger CI/CD

### Docker Development
1. Build and start: `docker-compose up --build`
2. Make changes
3. Rebuild: `docker-compose build app`
4. Restart: `docker-compose restart app`

## 📈 Performance Optimizations

### MongoDB Indexes
```javascript
// Essential indexes for performance
db.tasks.createIndex({ "board_id": 1, "status": 1 })
db.tasks.createIndex({ "assigned_to": 1, "created_at": -1 })
db.tasks.createIndex({ "due_date": 1, "status": 1 })
```

### Redis Caching
- **Task queries** cached for fast retrieval
- **Session management** for user state
- **Rate limiting** for API protection

### Application Optimizations
- **Lazy loading** for large collections
- **Pagination** for list endpoints
- **Compression** for API responses
- **Connection pooling** for databases

## 🔒 Security Considerations

- **Non-root containers** for reduced attack surface
- **Environment-based secrets** (not hardcoded)
- **Input validation** with Spring Validation
- **HTTPS enforcement** in production
- **Health check endpoints** for monitoring

## 📚 Key Design Decisions

### Why MongoDB over SQL?
- **Document model** fits task management domain
- **Schema flexibility** for evolving requirements
- **Better performance** for read-heavy workloads
- **Natural JSON mapping** for REST APIs

### Why Docker?
- **Environment consistency** across dev/prod
- **Easy dependency management** 
- **Cloud deployment ready**
- **Scalable architecture**

### Why Azure Container Apps?
- **True serverless** containers
- **Free tier** for development
- **Auto-scaling** to zero
- **Integrated with Azure ecosystem**

## 🐛 Troubleshooting

### Common Issues

**MongoDB Connection Failed**
```bash
# Check if MongoDB is running
docker ps | grep mongo

# Start MongoDB
docker-compose up -d mongodb
```

**Redis Connection Failed**
```bash
# Check Redis status
docker logs <redis-container-id>

# Restart Redis
docker-compose restart redis
```

**Application Won't Start**
```bash
# Check logs
docker-compose logs app

# Rebuild application
docker-compose build --no-cache app
```

**Java Version Issues**
```bash
# Verify Java version
java --version

# Should be Java 21
```

## 📖 Further Reading

- [Spring Boot Documentation](https://spring.io/projects/spring-boot)
- [MongoDB Documentation](https://docs.mongodb.com/)
- [Azure Container Apps Documentation](https://docs.microsoft.com/en-us/azure/container-apps/)
- [Docker Documentation](https://docs.docker.com/)
- [DDIA Book](https://dataintensive.net/) - Database design principles

**Built with ❤️ using modern cloud-native technologies**